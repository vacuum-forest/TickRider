--[[                                                 
                                       __¬,                                     
                                      ;|=);                                     
                                     .||v‡|;                                    
                                     =’zÒv|c                                    
                                     -∆B’£dE                                    
                                     ˙)1—Í„5                                    
                                      ˙{∞nIv         ._____.                    
   _‹.  _, _“                       :;:-:;˜ƒ:       j≤◊≤◊≤◊p˙        j€€€≤Â     
   j€€€€€€€€€                      ˘:;=;:_ø_|-.     ÿ•◊◊◊◊◊@˘        ﬁ€€≤€≤     
   ﬁ≤”œﬁ€‚ ]€                     _¬a˜|=vÚ!*=++    ˙.=™◊≤◊◊0-        ﬁ€›ˇ€€;    
   ˚˝  ﬁ€/  ”                     =…W∏|||Æ|++|=.   .=_⁄◊◊◊≤E˘        ≤€E™€€'    
       ﬁ€`                       ˙I◊◊v≠|==˜=¬-:;   ˘˘ˇˆ◊≤◊◊◊.        ≤€≤€€≤     
       ﬁ€                         ƒ35vliiv∞mmc˘;   ˘|=;3◊◊≤Nˇ        €€€€≤˝     
       ﬁ€                         -v||=;=;=+˜=˘; .˙  -˘-ƒ"Ÿ          €€≤€p      
       ﬁ€r                        ˘n|Ò˜˘.|||==˘:_l..                ™€€‘€€.     
     j‹€€≤‹,                      ˙{+ˆ|::==:˘  ˙;:ˇˇ˘               j€≤ ≤€›     
     ≤€€€€€›                       -===;˙˘˙     ˘:˘˘                ﬁ€≤ ‘€€/    
                                    ˘:::        ˙˘                              
                                     =+:˙˘˘.                                    
                                    ˙=|;;++:=;                                  
                                    .=u¬c|++=;                         ø‹“      
                                    _v1I(-Òi.˙                         ﬁ€›      
                                    |ÒIs||||.                          ﬁ€›      
                                   ˙+|n∞˜++|=                          ﬁ€›      
                                    =in∞v+|{∏˙                         ≤€E      
      ™‹‹‹p                         +Òn∞Ò==’∞;                         ≤€f      
      ƒﬂ€≤”                         =l∞∞|˘={∞;                         €€`      
       j€›                         ˙+Iov= ;i∞©                        .€€       
       ]€›                         ˘=lol: :|ns                        j€≤       
        €›                         ˘+lvi˘ ˘|vn˙                       j€≤       
        €≤                         ˘+ÒÒ|˙ ˘=ln.                       ‘ﬂ”       
        €›                         ˘+ii=   ;iv-                                 
       ™€›                         ˘+i|:   :|v-.                                
       ‹€€p                        ˘+|=˘   ˘+vÒc                                
       ﬂﬂﬂ˝                        -=|;    ˙=vIc                     ≤€€€≤∑     
                                   :++:    ˙=nlc                     €€≤≤€€p    
                                   ;++-    ˙=nIc                     €€  ﬁ€≤    
                                  ˙;+=˘     ivÒc                    ]€€   €€r   
                                  ˘;+;˘    ˙=v|(                    j€≤   ≤€k   
                                  ˙=+:     ˙ƒIÒ©                    ﬁ€›   ≤€f   
                                  ¬c=˘     ˙;+⁄c                    ﬁ€›  ™€€'   
                                  3m‡.     ˙:+—C                    ﬁ€› .‹€≤    
        ÷““                      ˙]Qk˙      :={c                    ≤€≤≤€€€˝    
      ™≤€€€                      :ˆY(      ˙:+|;                    €€€€€≤˝     
      ﬁ€≤ﬂﬂ                      :=+:      ˙:=+;                                
     _€≤                         :=+:       :++;                                
     ]€f                         ;=+:..:=:===++;                                
     ]€f                         ==|-jgø=:;vi+++.                     ‹‹‹‹‹p    
     ‘€›                        ˙=™%=Q◊Wc==v£)∞¬c.                    ≤€€€€›    
      €› j€                      ;)1=◊◊W‰|In∆gu{‚.                    €€”””'    
      ≤€≤€›                      ,⁄øj◊◊#—i—#—WWmp.                   _€€        
      ‘€€≤'                     .m◊±◊◊Q#Íu˛Ê∞#mQ◊c                   j€€€€€'    
                                =#Q«◊R#Ô∞mqkmmWQWe˘                  ﬁ€€≤≤≤     
                                -ÏÏÔÁiÒx∞Ô◊ÍWQQ◊QZø…ø˘               ﬁ€›        
                                :|IvvllZZÎk∆E#dM◊Àn7◊p               ﬁ€›        
                                :|lvlllXmmnÿ‡WÀumQÊˇ]◊               ≤€›÷÷⁄     
                                ™¬xÍ¬ÒI„#WX∆S#◊mQQE jF               ≤€€€€›     
                                -XmmÍmmZ„„„XdEQ◊m◊f.W`               ﬂﬂﬂﬂﬂ˝     
                                 )ÏÏÏZWmÊÍ„mWQÌVQ@')f                           
                                ™—Ø=|{XÔ#∞}Z3Q‡’◊‡˘]c                           
    ‹‹‹‹ ‹‹‹,                 _⁄}¯˘::|I∞∞„˜Î—◊BiQ◊ -!˙                          
    ﬂ€€ﬂﬁ€≤€f              ._uT~˘   ˙˘:=v{£ˆ3◊•ƒƒ¸q;:.               j€€€≤Â     
     ﬁ€©≤≤'              ø⁄|~˘         .∞+—‡˘-ˇ ˘;?ÎQ◊c              ﬁ€€≤€≤     
     ﬁ€≤€`       ˙_ø⁄q¬yu0~            =o`ƒ~˙    ˇ™n◊◊◊‡             ﬁ€›ˇ€€,    
     ﬁ€€≤,     .jÀ◊◊◊◊ZÍ~˘             .©         -Á3•◊◊;            ≤€E™€€'    
     ﬁ€M€≤,   _…◊◊≤◊◊W‚`               Ú`           ˇ{ÿV`            ≤€≤€€≤     
     ﬁ€fﬁ€‹   ]MM◊◊•ÿ'                _Ø             ˘)ø,            €€€€≤˝     
    _ﬁ€›-≤€≤÷  ˙ "ˇ˘                 ™◊;               4◊;           €€≤€p      
   j€€€€‹‘€€€f                       ]@ˇ               -4Qaø        ™€≤˚€€.     
   ‘ﬂ””ﬂ” )ﬂﬂ'                      .Q(                  ]◊◊◊ø.     j€≤ ≤€›     
                                   ˙j◊©                  ƒQ◊≤◊Qø    ﬁ€≤ ‘€€/    
                                   j≤±[                   )◊◊Q◊Qp˘              
                                  ™◊◊◊©                    -9◊◊≤◊Â              
                                 .Q◊◊@˘                      ¿◊◊◊f              
                                 ]±Q◊[                        ˇ-ˇ˙              
                                .◊◊≤E˘                                          
                                =◊◊◊'                                           
                                ˇÿ@`                                            
                                                                                
Tick Rider:

A shadowy flight into the dangerous world of a cyborg who does not exist (soaring on god's wings of spoiled pudding.)

Kurinn takes no responsibility and all of the credit for this abomination!

------------------------------------------------------

History:

Version 0.1ß: Feb. 15, 2021
---------------------------
	- Initial Tentative Release

Version 0.2ß: Feb. 16, 2021
---------------------------
	- External accelerations (weapons recoil, etc) can knock players off a tick (see knockoffThreshold)
	- Damage can knock riders off a tick (see damageKnockoffThreshold)
	- Improved tick spawn distribution (Thank you, Treellama!)

------------------------------------------------------

Instructions/Controls:
Press the action key to mount or dismount from a tick. Aim carefully and possibly get a running start? Try hopping from tick to tick, remembering to press action again to grab on.
Pressing and/or holding the mic key will allow the player to perform their best imitation of a tick call, which sould lure some over to you.
Whilst riding a tick, pressing both weapon cycle keys simultaneously will perform some 'gentle persuasion' on the tick and possibly get it to go somewheres else.

]]

Triggers = {}

Game.proper_item_accounting = true

CollectionsUsed = { 3 }		-- For the Ticks!

-- Happy User-friendly-ish Configurables For Easy Relaxation and Prosperity:
-------------------------------------------------------------------------------

--Tick/Cyborg Conjugal Regulations
	maxTickMountDistance = 3.5 		-- Maximum xy distance from tick for player mount attempt
	maxTickMountHeight = 2.5		-- Maximum z distance from tick for player mount attempt
	maxTickMountAngle = 90			-- Maximum tick bearing off player yaw for mount attempt
	graspReach = 2					-- Maximum distance from tick for player to mount
	jumpForce = 0.15				-- Total scalar for boost acceleration
	verticalCoefficient = 1.25		-- Scale vertical boost acceleration
	knockoffThreshold = 0.2083		-- Player external acceleration sufficient to cause a dismount. (<0.2083: Rocket, <0.0835: Grenade)
	
--Violence of Conservation of Momentum
	damageKnockoffThreshold = 45	-- Minimum amount of damage required to knock a rider off its tick

--Tick/Cyborg Communications
	tickCallDistance = 20			-- Maximum range of the Tick Whistle®

--Tick Traffic Laws
	exclusionHeight = 1.5			-- This will attempt to discourage tick infiltration into certain polygons with less vertical span
	saddleHeight = 0.4				-- Height of rider.z relative to tick.z
	downDraft = 0.02				-- Vertical velocity (down) increment per tick to avoid head-in-void syndrome

--Tick Aggression Limiter
	allowFriendlyFire = true		-- When false, prevent damage dealt to tick by rider projectiles

--Tick Spawnin' Parameters
	spareTicks = 7					-- Always have at least this many free ticks around. (Warning: too many ticks can cause problems, some of which may be /fun/!)
	kamikazeOdds = 7				-- 1 in n chance that next tick will be a kamikaze
	majorOdds = 5					-- 1 in n chance that next tick that isn't a kamikaze will be a major

--Tick Social Coefficients
	tickWrathDuration = 3600		-- How long in ticks the player will be hated by ticks after beating their tick to death
	tickRageRadius = 30				-- Distance in WU for a tick to attempt revenge against a player
	tickAttackFrequency = 45		-- Time in ticks between attack commands given to vengeful ticks in player polygon (not too low, please!)

--Tick Psychological Settings
	maxTickStability = 1000			-- Time divided probability of tick spontaneous explosion (kamikaze w/ rider)
	maxTickImpatience = 45			-- Time in ticks before new destination for stuck ticks

--Tick Actuarial Tables
	MonsterTypes["minor tick"]._maxLife = 30		-- This amount of life is assigned to all ticks of this class
	MonsterTypes["major tick"]._maxLife = 60
	MonsterTypes["kamikaze tick"]._maxLife = 90

tickDebug = false



-- Trigger Functions
-----------------------------------------------------------

function Triggers.init()
	
	initialKamikazeOdds = kamikazeOdds

	tickSafePolygons = {}
	
	for p in Polygons() do
		
		if not polygonIsTickSafe(p) then
			if p.type == "normal" then
				p.type = "monster impassable"	-- Try to keep ticks from pathing into tricky spots
			end
			tickSafePolygons[p.index] = false
		else
			tickSafePolygons[p.index] = p
		end
		
	end

	for p in Players() do
		
		-- Avoid tick-unfriendly starting positions
		if not polygonIsTickSafe(p.polygon) then
			local polygon = pickRandomSafePolygon()
			p:position(polygon.x, polygon.y, polygon.floor.z, polygon)
		end

		p._tickVengeanceLevel = 0
		p._tickCallCooldown = 0
		p._grabTick = false
		
		p._external_acceleration = {
			["x"] = 0,
			["y"] = 0,
			["z"] = 0
		}
		
		p._last_external_velocity = {
			["x"] = p.external_velocity.x,
			["y"] = p.external_velocity.y,
			["z"] = p.external_velocity.z
		}
		
		if tickDebug then
			gimmeTheJUICE(p)
		end
	
	end
	
	-- You get a tick, and you get a tick! Everybody gets a tick!
	for m in Monsters() do

		if m.type.class ~= "tick" then
			giveTick(m)
		end
		
	end

end


function Triggers.projectile_created(projectile)

	if projectile.owner._tick and projectile.owner.monster then
		updateExternalAcceleration(projectile.owner)
	end

end


function Triggers.player_revived(p)

	giveTick(p)

end


function Triggers.player_damaged(victim, aggressor_player, aggressor_monster, damage_type, damage_amount, projectile)
	
	if victim._tick then
	
		updateExternalAcceleration(victim)
		
	end
	
end


function Triggers.monster_damaged(monster, aggressor_monster, damage_type, damage_amount, projectile)
	
	--Ticks Only
	if monster.type.class == "tick" then
		
		if aggressor_monster ~= nil then
			
			if monster._rider ~= nil then
		
				if not allowFriendlyFire then
					if aggressor_monster.player == monster._rider or aggressor_monster == monster._rider then
						monster.life = monster.life + damage_amount
					end
				end
		
			end

		-- Tick Abuse Protocol
		elseif damage_type == "fusion" then
			
			if monster.life > 0 then
			
				monster:play_sound("fist hitting")
			
			else
		
				monster:play_sound("crushed")

				-- Tick abuse may result in a tick vendetta! You have been warned!
				if monster._rider ~= nil then
					monster._rider._tickVengeanceLevel = monster._rider._tickVengeanceLevel + tickWrathDuration
				end

				-- Spawn kamikazes more often whenever someone beats a dead tick
				if kamikazeOdds > 2 then
					kamikazeOdds = kamikazeOdds - 1
				end
				
			end

		end
		
		if monster.life <= 0 and not monster._deathNoted then
			
			if aggressor_monster == nil then
				
				if damage_type == "lava" then
					Players.print(monster._name .. " just got turned into tick stew in the lava!")
				elseif damage_type == "goo" then
					Players.print(monster._name .. " has become at one with the goo!")
				elseif damage_type == "fusion" then
					Players.print(monster._name .. " was abused to death by " .. tostring(monster._rider.name) .. "! That monster!")
				elseif damage_type == "explosion" then
					Players.print(monster._name .. " was blasted to death in an explosion!")
				end
				
			else
				
				local killer
				if aggressor_monster.player then
					killer = aggressor_monster.player.name
				else
					killer = "a " .. tostring(aggressor_monster.type)
				end
				
				Players.print(monster._name .. " was killed by " .. tostring(killer) .. " with a " .. tostring(projectile.type) .. "!")
				
			end
			
			-- Funny(?) death reactions
			if string.find(monster._name, "Kenny") then
				Players.print("Oh my god, you killed Kenny! You bastards!")
			elseif string.find(monster._name, "Homer") then
				Players.print("D'oh!")
			elseif string.find(monster._name, "King") then
				Players.print("The king is dead! Long live the king!")
			end
			
			monster._deathNoted = true
			
		end
		
	else
		
		if monster._tick then
			monster._cumulativeTickDamage = monster._cumulativeTickDamage + damage_amount
			
			if monster._cumulativeTickDamage >= damageKnockoffThreshold then
				dismountTick(monster)
			end
			
		end
		
	end
	
end


function Triggers.monster_killed(monster, aggressor_player, projectile)
	
	-- Remove corpses from back of tick, yes?
	if monster._tick or monster._rider then
		
		dismountTick(monster)
		
	end
		
	if monster.type.class == "tick" then
		
		if aggressor_player then
		
			-- Add to tick rage cooldown if tick abuser wastes a tick while under tick vendetta
			if aggressor_player._tickVengeanceLevel > 0 then
				aggressor_player._tickVengeanceLevel = aggressor_player._tickVengeanceLevel + 450
			end
		
		end
		
	end
	
end


function Triggers.idle()

	angryTicks = false
	ticksAlive = 0
	ticksAvailable = 0
	monstersAlive = 0
	
	timersIdleUpkeep()

	for m in Monsters() do
		
		if m.life >= 0 and m.valid and not m.player then
		
			m.active = true
		
			if m.type.class == "tick" then

				ticksAlive = ticksAlive + 1
				
				if not m._rider then
					ticksAvailable = ticksAvailable + 1
				end
				
				updateTick(m)
				
			else
				
				monstersAlive = monstersAlive + 1
				
			end
		
		end
		
	end
	
	for p in Players() do
		
		updatePlayer(p)

		updateOverlays(p)
		
	end

	-- If no players have angered the tick gods, ease off on the exploding ticks
	if not angryTicks then
		kamikazeOdds = initialKamikazeOdds
	end
	
	-- Maintain a steady population of available ticks
	if ticksAvailable < # Players + spareTicks then
		summonTick()
	end
	
end


function Triggers.postidle()

	for m in Monsters() do
		if m.type.class == "tick" and m._rider then
			m._rider:position(m.x, m.y, m.z + saddleHeight, m.polygon)
		end
		m._cumulativeTickDamage = 0
	end
	
end



-- Tick Functions
-----------------------------------------------------------

function createTick(x, y, z, polygon, safe)

	if Game.random(kamikazeOdds) == 0 and not safe then
		tickBreed = "kamikaze tick"
	elseif Game.random(majorOdds) == 0 then
		tickBreed = "major tick"
	else
		tickBreed = "minor tick"
	end
	
	local tick = Monsters.new(x, y, z, polygon, tickBreed)
	tick:position(x, y, z, polygon)
	
	tick._name = tickName(tick)
	
	if string.find(tick._name, "Impervious") then
		tick.life = 3000
	elseif string.find(tick._name, "Titanium") then
		tick.life = 500
	elseif string.find(tick._name, "Hardy") then
		tick.life = 200
	else
		tick.life = tick.type._maxLife
	end
	
	tick._maxLife = tick.life
	tick._lastPosition = {}
	tick._lastPosition.x = tick.x
	tick._lastPosition.y = tick.y
	tick._lastDestination = tick.polygon
	tick._nextDestination = tick.polygon
	tick._stabilityLevel = maxTickStability
	tick._impatienceLevel = 0
	tick._attackCooldown = 0

	return tick
	
end


function summonTick()
	
	local polygon = pickRandomSafePolygon()
	local x
	local y
	x, y, polygon = uniform.xy_in_polygon(polygon)

	local floor
	if polygon.media then
		floor = math.max(polygon.floor.z, polygon.media.height) + 0.25
	else
		floor = polygon.floor.z + 0.25
	end
	local span = polygon.ceiling.z - floor - 0.25
	local z = Game.random(math.floor(span * 10000) + 1) * (span / 100000)
	
	boof(polygon.x, polygon.y, z + floor, polygon)
	local tick = createTick(x, y, z + floor, polygon)
	
end


function giveTick(monster)

	local tick = createTick(monster.x, monster.y, monster.z, monster.polygon, true)
	
	if monster.player then
		mountTick(monster.player, tick)
	else
		mountTick(monster, tick)
	end
	
end


function mountTick(rider, tick)
	
	tick._rider = rider
	rider._tick = tick
	
	tick:accelerate(0, 0, -0.01)
	
	moveTick(tick)
	
end


function dismountTick(monster)

	if monster._rider then
		monster._rider._tick = nil
		monster._rider = nil
	elseif monster._tick then
		monster._tick._rider = nil
		monster._tick = nil
	end
	
end


function moveTick(tick)
	
	if tick then
		if not tick.valid then
			return
		end
	else
		return
	end
	
	local targetPolygon = pickRandomSafePolygon()
	
	if not targetPolygon then
		return moveTick(tick)
	end
	
	tick:move_by_path(targetPolygon)
	
	tick._previousDestination = tick.polygon
	
	tick._nextDestination = targetPolygon
	
	tick._impatienceLevel = 0
	
end


function updateTick(tick)
	
	if tick._lastPosition.x == tick.x and tick._lastPosition.y and math.abs(tick.vertical_velocity) < 0.07 then
		tick._impatienceLevel = tick._impatienceLevel + 1
	end
	
	tick._lastPosition.x = tick.x 
	tick._lastPosition.y = tick.y
	
	if tick._impatienceLevel >= maxTickImpatience then
		
		if tick.type == "kamikaze tick" then
			tick:damage(0)
		end
		
		tick.polygon:play_sound(tick.x, tick.y, tick.z, "tick chatter", 0.5)
		
		moveTick(tick)
		
	end
	
	-- For ticks with a rider aboard:
	if tick._rider then
		
		local rider = tick._rider
		
		-- Avoid inserting rider head into ceiling
		local riderHeight = rider.monster == nil and tick._rider.type.height or tick._rider.monster.type.height
		if rider.z + riderHeight >= tick.polygon.ceiling.z - 0.1 then
			--tick.vertical_velocity = tick.vertical_velocity - downDraft
			tick.vertical_velocity = math.min(0 - tick.vertical_velocity, 0)
		end	
		
		-- Keep ticks moving to new and exciting locations!
		if tick.polygon == tick._nextDestination then
			
			moveTick(tick)
				
		end
		
		-- Keep rider positioned above tick
		rider:position(tick.x, tick.y, tick.z + saddleHeight, tick.polygon)
		
		-- Some might say they're... unstable?
		if tick.type == "kamikaze tick" then
			if tick._stabilityLevel > 2 then
				tick._stabilityLevel = tick._stabilityLevel - 1
			end
			if Game.random(tick._stabilityLevel) == 0 then
				tick:play_sound("rocket exploding")
				Effects.new(tick.x, tick.y, tick.z, tick.polygon, "rocket explosion")
				rider:damage(100,"explosion")
				tick:damage(100)
			end
		end
		
	else
		
		-- Riderless tick stuff goes here
	
	end
	
	-- Kamikaze tick stuff
	if tick.type == "kamikaze tick" then
		
		-- Tick Vengeance Protocol:
		
		if Game.ticks % 15 == 0 then
		
			tick._targetTickAbuser = nil
			local closestJerkfaceDistance = tickRageRadius
		
			for p in Players() do
			
				if p._tickVengeanceLevel > 0 then
				
					local buttheadRange = getDistance3(tick.x, tick.y, tick.z, p)
				
					if buttheadRange <= closestJerkfaceDistance then
						tick._targetTickAbuser = p
						closestJerkfaceDistance = buttheadRange
					end

				end	
			
			end
			
		end
			
		if tick._targetTickAbuser then
		
			if tick.polygon ~= tick._targetTickAbuser.polygon then
				if Game.ticks % 300 == 0 then
					tick:move_by_path(tick._targetTickAbuser.polygon)
					tick:play_sound("tick chatter")
				end
			else
				if not tick._attackTimer then
					local sicEm = function()
						tick:play_sound("tick chatter")
						tick:attack(tick._targetTickAbuser.monster)
					end
					tick._attackTimer = createTimer(tickAttackFrequency, false, sicEm)
				end
			end
			
		end
		
	end
	
	-- Special case behaviors...
	if string.find(tick._name, "Flatulent") and Game.random(30) == 7 then
	
		local fart = Effects.new(tick.x, tick.y, tick.z, tick.polygon, "juggernaut missile contrail") 
		tick.polygon:play_sound(tick.x, tick.y, tick.z, "absorbed", 0.5)
		
	elseif string.find(tick._name, "Saint") and Game.random(300) == 7 then
		
		if tick._rider then
			if tick._rider.life < 100 and tick._rider.monster then
				tick._rider.life = tick._rider.life + 10 + Game.random(30)
				tick:play_sound("tick chatter")
				tick._rider:fade_screen("white")
				if tick._rider.life > 100 then
					tick._rider.life = 100
				end
			end
		end
		
	elseif string.find(tick._name, "Magical") and Game.ticks % 900 == 0 then
		
		if tick._rider.monster then
			
			local diceRoll = Game.random(7)
			castWonder(diceRoll, tick._rider)
				
		end
		
	elseif string.find(tick._name, "Fun Robert") and Game.ticks % 150 == 0 then
		
		if Game.random(2) == 0 then
			tick.polygon:play_sound(tick.x, tick.y, tick.z, "assimilated vacbob chatter", 0.5)
		end
		
	end
	
end



-- Player Functions
-----------------------------------------------------------

function updatePlayer(player)

	-- Tick vendetta decrementation
	if player._tickVengeanceLevel > 0 then
		angryTicks = true
		player._tickVengeanceLevel = player._tickVengeanceLevel - 1
	end
	
	if player._tickCallCooldown > 0 then
		player._tickCallCooldown = player._tickCallCooldown - 1
	end
	
	-- Avoid riding dead ticks, it's bad for you!
	if player._tick then
		if not player._tick.valid then
			dismountTick(player)
		end
	end
	
	-- Corpses can't ride a tick
	if player.dead then
		
		dismountTick(player)
		
	-- How to get on a tick?	
	elseif player._grabTick then
		
		local ticksAbout = false
		
		-- (NOTE: There's a better way to do this, probably. It just grabs the first tick it 'sees' and is good enough, but that may not be the closest one!)
		
		for m in Monsters() do
			if m.type.class == "tick" then
				if isRideableTick(m) then
					if getDistance3(m.x, m.y, m.z, player) <= graspReach then
				
						if math.abs(angleDifference(getBearing(player, m), player.yaw)) < 70 then
							mountTick(player, m)
							m:play_sound("tick chatter")
							player._grabTick = false
							break
						end
						
					elseif getDistance3(m.x, m.y, m.z, player) <= maxTickMountDistance then
						
						ticksAbout = true
						
					end
				end
			end
		end
		
		if not ticksAbout then
			player._grabTick = false
		end
		
 	-- Mount/dismount
	elseif player.action_flags.action_trigger then
		
			if player._tick then
				dismountTick(player)
				bigLeap(player, true)
			else
				rideTick(player)
			end
	
	-- The mic button sucks but it's what we've got right now. Hawtkeyz nao plz~
	elseif player.action_flags.microphone_button then

		player.action_flags.microphone_button = false
		
		callTick(player)

	-- Tick abuse protocol:
	elseif player.action_flags.cycle_weapons_backward and player.action_flags.cycle_weapons_forward then
		
		if player._tick ~= nil then
			player.action_flags.action_trigger = false
			if Game.random(3) == 1 then
				player._tick:play_sound("tick chatter")
			end
			player._tick:damage(1, "fusion")
			moveTick(player._tick)
		end	
		
	end
	
	if tickDebug then
		player.life = 3000
		player.oxygen = 3000
	end
	
	updateExternalAcceleration(player)
	
end


function rideTick(player)

	if player._grabTick then
		return
	end

	for m in Monsters() do
		
		if m.type.class == "tick" then
			
			local xyDistance = getDistance2(m.x, m.y, player)
			local zDistance = m.z - player.z
			
			if xyDistance <= maxTickMountDistance and zDistance <= maxTickMountHeight and isRideableTick(m) then
				
				local bearing = getBearing(player, m)
				local alpha = angleDifference(bearing, player.yaw)
				
				if math.abs(alpha) <= maxTickMountAngle then
					
					player._grabTick = true
					bigLeap(player)
					
				end
	
			end
		end
	end
	
	player:play_sound("cant toggle switch", 1.5)
	
end

--[[
The following is not the best possible implementation, but it's something.
Note that jumps on dismounts get a bit more oomph because for whatever reason those jumps need it to get the same results
as jumping from the ground? May be a good reason for this but I'm too tired to consider it in depth...
]]

function bigLeap(player, dismount)
	
	local pitch = player.pitch
	
	local verticalMinimum = 0.02
	if dismount then
		verticalMinimum = 0.175
	end
		
	local fThrust = jumpForce * math.cos(math.rad(pitch))
	local vThrust = math.max(jumpForce * math.sin(math.rad(pitch)) * verticalCoefficient, verticalMinimum)

	if player.z == player.polygon.z or dismount then
		player:accelerate(player.yaw, fThrust, vThrust)
	end

end


--(NOTE: Maybe add some more color pallettes for the icon to indicate TICK RAGE or something, I dunno.)

function updateOverlays(player)
	
	for i = 0, 5 do
		player.overlays[i]:clear()
	end

	if player._tick ~= nil then
	
		local tickHealth = player._tick.life / player._tick._maxLife * 100
		local healthSpace
		if tickHealth == 100 then
			healthSpace = "         "
		elseif tickHealth >= 10 then
			healthSpace = "          "
		else
			healthSpace = "           "
		end
	
		player.overlays[0].text = healthSpace .. string.format("%i", tickHealth) .. "%"
	
		if tickHealth >= 90 then 
			player.overlays[0].color = "dark green"
		elseif tickHealth >= 70 then
			player.overlays[0].color = "green"
		elseif tickHealth >= 30 then
			player.overlays[0].color = "yellow"
		elseif tickHealth >= 15 then
			player.overlays[0].color = "red"
		else
			if Game.ticks % 30 > 15 then
				player.overlays[0].color = "red"
			else
				player.overlays[0].color = "dark red"
			end
		end
	
		player.overlays[1].icon = iconTick
	
		player.overlays[1].text = " " .. player._tick._name
	
		if player._tick.type == "minor tick" then
			player.overlays[1].color = "green"
		elseif player._tick.type == "major tick" then
			player.overlays[1].color = "blue"
		elseif player._tick.type == "kamikaze tick" then
			player.overlays[1].color = "red"
		else
			player.overlays[1].color = "cyan"
		end
	
	else
		
		if tickDebug then
			player.overlays[1].icon = nil
			player.overlays[0].text = string.format("%5.3f", player.external_velocity.x)
			player.overlays[1].text = string.format("%5.3f", player.external_velocity.y)
			player.overlays[2].text = string.format("%5.3f", player.external_velocity.z)
			player.overlays[3].text = string.format("%5.3f", player._external_acceleration.x)
			player.overlays[4].text = string.format("%5.3f", player._external_acceleration.y)
			player.overlays[5].text = string.format("%5.3f", player._external_acceleration.z)
		end
		
	end

end


function callTick(player)

	if player._tickCallCooldown == 0 then

		for m in Monsters() do
			if m.type.class == "tick" and m.type then
				if m._rider == nil and m._targetTickAbuser == nil and m.life > 0 and m.valid and getDistance3(m.x, m.y, m.z, player) <= tickCallDistance then
					
					if m.polygon ~= player.polygon then
						m:move_by_path(player.polygon)
					else
						m:attack(player.monster)
					end
					
					if tickDebug then
						Players.print(m._name .. " responding to " .. player.name .. "'s tick call!")
					end
					
				end
			end
		end
		
		player.polygon:play_sound(player.x, player.y, player.z, "tick chatter", 3)

		player._tickCallCooldown = 60
		
	end
	
end


function updateExternalAcceleration(player)
	
	player._external_acceleration = {
		["x"] = (player.external_velocity.x - player._last_external_velocity.x) / 30,
		["y"] = (player.external_velocity.y - player._last_external_velocity.y) / 30,
		["z"] = (player.external_velocity.z - player._last_external_velocity.z) / 30
	}
	
	player._last_external_velocity = {
		["x"] = player.external_velocity.x,
		["y"] = player.external_velocity.y,
		["z"] = player.external_velocity.z
	}
	
	player._scalar_acceleration = math.sqrt(player._external_acceleration.x^2 + player._external_acceleration.y^2 + player._external_acceleration.z^2)
	
	if player._tick then
		
		if player._scalar_acceleration > knockoffThreshold then
			dismountTick(player)
		end
		
	end
	
end



-- Timers
-----------------------------------------------------------

Timers = {}

TimerList = {}

function createTimer(period, repeating, action)

	local timer = Timers:new()
	
	timer.period = period - 1
	timer.repeating = repeating
	timer.action = action
	
	timer.count = period
	timer.status = "live"
	
	table.insert(TimerList, timer)
	
	return timer
	
end


function Timers:execute()

	self.action()

	if self.repeating then
	
		self:reset()
	
	else
		
		self.status = "dead"
		
	end
	
end


function Timers:reset()
	
	self.count = self.period
	
end


function Timers:kill()

	self.status = "dead"

end


function Timers:evaluate()

	if self.status == "dead" then
		self = nil
		return
	end

	if self.count <= 0 then
		self:execute()
		return
	end
	
	self.count = self.count - 1
	
end


function Timers:new()
	
	o = {}
    setmetatable(o, self)
    self.__index = self
	return o
	
end


function timersIdleUpkeep()

	local newSet = {}

	for i = 1, # TimerList, 1 do
		
		TimerList[i]:evaluate()
		if TimerList[i].status == "live" then
			table.insert(newSet, TimerList[i])
		end
		
	end

	TimerList = newSet
	
end



-- Assorted Functions and Errata
-----------------------------------------------------------

function getDistance2(x, y, object)
	
	return math.sqrt((object.x - x)^2 + (object.y - y)^2)
	
end


function getDistance3(x, y, z, object)
	
	return math.sqrt(getDistance2(x, y, object)^2 + (object.z - z)^2)
	
end


function getBearing(from, to)
	
	local x = to.x - from.x
	local y = to.y - from.y
	local theta = math.deg(math.atan(y/x))
	if x < 0 then
		return theta + 180
	elseif y < 0 then
		return theta + 360
	else
		return theta
	end
	
end


function angleDifference(a, b)

	return (a - b + 540) % 360 - 180

end


function radToCart(angle, radius)
	
	if (radius == nil) or (angle == nil) then
		return false
	end
	local x = math.cos(math.rad(angle)) * radius
	local y = math.sin(math.rad(angle)) * radius
	return x, y
	
end


function cartToRad(x, y)

	local scalar = math.sqrt(x * x + y * y)
	
	local nx = 0
	local ny = 0
	
	if scalar ~= 0 then
		nx = x / scalar
		ny = y / scalar
	else
		nx = 0
		ny = 0
	end	
	
	local angle = math.deg(math.atan2(ny, nx))
	if angle < 0 then angle = angle + 360 end
	
	return angle, scalar
	
end


function offsetRadial(x, y, angle, radius)

	local xr, yr = radToCart(angle, radius)
	
	return x + xr, y + yr
	
end


function polygonIsTickSafe(polygon)
	
	if polygon.media then
		if polygon.media.height >= polygon.ceiling.z or polygon.ceiling.z - polygon.media.height < exclusionHeight then
			return false
		end
	end
	
	return polygon.ceiling.z - polygon.floor.z >= exclusionHeight and polygon.area > 0.1
	
end


function pickRandomSafePolygon()

	local safePolygon = tickSafePolygons[Game.random(# tickSafePolygons)]
	
	if not safePolygon then
		return pickRandomSafePolygon()
	else
		return safePolygon
	end
	
end


function boof(x, y, z, polygon)
	
	local boof = Effects.new(x, y, z, polygon, "rocket contrail")
	boof:play_sound("enforcer exploding")
	
end


function isRideableTick(tick)
	
	return tick._rider == nil and tick.life > 0 and tick.valid
	
end


function tickName(tick)

	local a = Game.random(# TickNames) + 1
	local b = "Unidentifiable"
	if tick.type == "minor tick" then
		b = TickAdjectivesMediocre[Game.random(# TickAdjectivesMediocre) + 1]
	elseif tick.type == "major tick" then
		b = TickAdjectivesGood[Game.random(# TickAdjectivesGood) + 1]
	elseif tick.type == "kamikaze tick" then
		b = TickAdjectivesUgly[Game.random(# TickAdjectivesUgly) + 1]
	end

	return b .. " " .. TickNames[a]
	
end

TickNames = {

	"Jimmy","Rosie","Slim","Suzy","Ozzy","Becky","Chuck","Lucy","Red","Pinto","Orville","Jenny","Ted","Missy","Bart","Rex","Tom","Boz","Corky","Fido","Iggy","Chet","Buddy","Dan","Ralph",
	"Lenny","Gus","Ronnie","Marie","Baxter","Chester","Dexter","Laszlo","Rufus","Hector","Hannibal","Cameron","Bingo","Mary","Sam","Al","John","Jessie","Karen","Leonardo","Puck","Alfonso",
	"Lizzie","Peg","Anna","Tina","Olga","Elsie","Bessy","Agnes","Bertha","Bridget","Mavis","Daisy","Dolores","Eunice","Glynis","Helga","Maude","Mildred","Penelope","Roxanne","Tammy","Arthur",
	"Felix","Harry","Homer","Marge","Jasper","Rupert","Oscar","Simon","Jules","Gideon","Howard","Holden","Spencer","Benny","Mikey","Leo","Bert","Ray","Moppy","Lonny","Ike","Abe","Joe","Kenny",
	"Andy","Randy","Carl","Bixby","Bill","Sonny","Frannie","Francis","Frankie","Robert"
	
}

TickAdjectivesMediocre = {
	
	"Fat","Fluffy","Ugly","Chubby","Impetuous","Curious","Cotton Eye","Soggy","Queazy","Scuzzy","Corpulent","Expendable","Lazy Eyed","Ham-fisted","Sad-sack","Sickly","Antsy","Nauseous","Scared",
	"Giddy","Needy","Pandering","Wandering","Sleepy","Bashful","Indeterminate","Paranoid","Lazy","Generic","Standard-issue","Fake Teeth","Drunk","Ancient","Wet","Smelly","Incontinent","Incompetent",
	"Economical","Slow","Lil'","Sorry","Weepy","Shaky","Cashed Out","Sloppy","Forgetable","Milquetoast","Mild","Childproof","Dorky","Counterfeit","Corroded","Inexperienced","Saggy","Poopy-pants",
	"Humble","Soft Serve","Impotent","Dandruff","Waterlogged","Stressful","Flatulent","Hungry Hungry","Cool Ranch","Sweet & Sour","Low Calorie","Low Sodium","Lactose-free","No MSG","Aggregate-grade",
	"Feckless","Fun","Dirty","Fun-size","Chintzy","Dandruff","Mildew","Pet Odor","Lyme Disease","Petulant","Two-bit","Five & Dime","Bargain-bin","Best-by Last Week","Discount","Cut-rate","Fly-by-Nite",
	"Bald Spot","Sooty"
	
}

TickAdjectivesGood = {
	
	"Slick","Lovely","Most Honorable","Harmonious","Lucky","Cromulent","Savvy","Fun Lovin'","Fantastic","Dead-eye","Rugged","Dreamy","Can-do","Superlative","Gutsy","Sincere","The Incredible",
	"Super-duper","Resolute","Heroic","Hardcore","Serious","Impervious","Magical","Resplendent","Outstanding","God-hand","Major","No-guff","Legendary","Wholesome","Deluxe","Emperor","Bad-ass",
	"Majestic","Mysterious","Helpful","Hardy","Heavy-duty","Radical","Darling","Wunderkind","Captain","Lord","Saint","Titanium","Royal","Ingenious","Clever","Sporty","Luxurious","Infinite","King",
	"Duke","Slammin'","Bushwhacker","Tireless","Peerless","The One and Only","Top-class","Elegant"
	
}

TickAdjectivesUgly = {
	
	"Grumpy","Touchy","Crazy","Cantankerous","Sleazy","Sketchy","Shady","Hateful","Impish","Evil","Malevolent","Psychotic","Awful","Rotten","Vile","Laviscious","Rude","Rueful","Ghastly",
	"Cold-hearted","Facetious","Slimy","Raunchy","Loathesome","Rotten","Excitable","Nightmare","Murderous","Baby-eating","Scandalous","Terrible","Horror-show","Killer","Villainous","Wicked",
	"Insane","Yellow-bellied","Damnable","Sinful","Thuggish","Graverobber","Felonious","Dangerous","Poisonous","War Criminal","That No-good","Dastardly","Con Artist","Deathly","Cannibalistic",
	"Delinquent","Heinous","Foul-mouthed","Inexcusable","Ravenous","Violent","Vicious"
}


function castWonder(diceRoll, player)

	if diceRoll == 0 then
		player.infravision_duration = 900
	elseif diceRoll == 1 then
		player.invincibility_duration = 900
	elseif diceRoll == 2 then
		player.invisibility_duration = 900
	elseif diceRoll == 3 then
		player.extravision_duration = 900
	elseif diceRoll == 4 then
		player.life = player.life + 100 + Game.random(100)
	elseif diceRoll == 5 then
		for i in ItemTypes() do
			if string.find(i.mnemonic,"ammo") then
				player.items[i] = player.items[i] + Game.random(7)
			end
		end
	else
		-- Add some other ridiculous thing here
	end
	
	player:fade_screen("dodge purple")
	player:play_sound("destroy control panel")

end


function showTicks()
	for m in Monsters() do
		if m._name then
			Players[0]:print(tostring(m._name) .. " " .. tostring(m.type))
		end
	end
end


function killTicks()
	for m in Monsters() do
		if m.type.class == "tick" then
			m:damage(1000)
		end
	end
end


function gimmeTheJUICE(player)

    player.items["pistol"] = 7
    player.items["pistol ammo"] = 7
    player.items["fusion pistol"] = 7
    player.items["fusion pistol ammo"] = 7
    player.items["assault rifle"] = 7
    player.items["assault rifle ammo"] = 7
    player.items["assault rifle grenades"] = 7
    player.items["missile launcher"] = 7
    player.items["missile launcher ammo"] = 7
    player.items["alien weapon"] = 7
    player.items["flamethrower"] = 7
    player.items["flamethrower ammo"] = 7
    player.items["shotgun"] = 7
    player.items["shotgun ammo"] = 7
    player.items["smg"] = 7
    player.items["smg ammo"] = 7
	
end


iconTick =
[[
22
,a0a1a4
.2f3137
a633e38
b604038
c865b4a
d49322c
eab725b
f936250
g4e3028
h694034
i392522
j402522
k452820
l543731
m432b22
n7a4b3d
o936250
p2d1b15
q261a19
r402d29
s5a413d
t7d574a
,,,,,,,,,,,,,,,,
,..............,
,......abcd....,
,.....eeefc....,
,....ghhaiji...,
,....gklgjlm...,
,....gnnogjp...,
,.....ppkjj....,
,....i.i.q.r...,
,...s..s.q..q..,
,..s..s...q..s.,
,..m.tf....d.f.,
,bg..e......lte,
,h...f.......sc,
,..............,
,,,,,,,,,,,,,,,,
]]


-- Uniform.lua by Gregory Smith
-- Random points in Aleph One's game world
--
-- you may freely redistribute this file and/or include it in your scripts
--
-- to find a random x,y,polygon or x,y,z,polygon in a list of polygons:
-- uniform.build_triangle_list(polygon_list)
-- uniform.xy_in_triangle_list(triangle_list)
-- uniform.xyz_in_triangle_list(triangle_list)
--
-- inefficient convenience functions:
-- uniform.xy_in_polygon(polygon)
-- uniform.xyz_in_polygon(polygon)

uniform = {}

function uniform.xy_in_polygon(polygon)
   return uniform.xy_in_triangle_list(uniform.build_triangle_list({polygon}))
end

function uniform.xyz_in_polygon(polygon)
   return uniform.xyz_in_triangle_list(uniform.build_triangle_list({polygon}))
end

function uniform.build_triangle_list(polygon_list)
   local triangles = {}
   local total_area = 0
   for _, p in pairs(polygon_list) do
      local polygon_triangles = uniform.split_polygon_into_triangles(p)
      for _, t in pairs(polygon_triangles) do
	 table.insert(triangles, t)
	 total_area = total_area + t.area
      end
   end

   local area = 0
   for _, t in pairs(triangles) do
      area = area + t.area / total_area
      t.weight = area
   end

   return triangles
end

function uniform.xy_in_triangle_list(triangles)
   local t = uniform.search(triangles, uniform.random())
   local x, y = uniform.xy_in_triangle(t)
   return x, y, t.polygon
end

function uniform.xyz_in_triangle_list(triangles)
   local x, y, p = uniform.xy_in_triangle_list(triangles)
   local z = p.floor.height + uniform.random() * (p.ceiling.height - p.floor.height)
   return x, y, z, p
end

function uniform.split_polygon_into_triangles(p)
   local triangles = {}
   local endpoints = p.endpoints
   local first = endpoints[0]
   for i = 1, # p.endpoints - 2 do
      local a = first
      local b = endpoints[i]
      local c = endpoints[i + 1]
      local triangle = {a, b, c}
      triangle.area = math.abs((a.x * b.y - b.x * a.y) + (b.x * c.y - c.x * b.y) + (c.x * a.y - a.x * c.y)) / 2
      triangle.polygon = p
      
      table.insert(triangles, triangle)
   end
   return triangles
end

function uniform.random()
   return Game.random() / (2 ^ 32)
end

function uniform.xy_in_triangle(t)
   local a = uniform.random()
   local b = uniform.random()
   if a + b > 1 then
      a = 1 - a
      b = 1 - b
   end
   local c = 1 - a - b

   local ta = t[1]
   local tb = t[2]
   local tc = t[3]

   local x = ta.x * a + tb.x * b + tc.x * c
   local y = ta.y * a + tb.y * b + tc.y * c

   return x, y
end

function uniform.search(triangles, weight)
   local function search(low, high)
      local mid = math.floor((low + high) / 2)
      if low == high then
	 return high
      elseif triangles[mid].weight > weight then
	 return search(low, mid)
      else
	 return search(mid + 1, high)
      end
   end
   return triangles[search(1, # triangles)]
end